#!/usr/bin/env node

/**\n * Comprehensive Deployment Testing Protocol\n * Blake's end-to-end validation for Netlify deployment readiness\n */\n\nconst fs = require('fs')\nconst path = require('path')\nconst { execSync } = require('child_process')\n\nfunction runTest(testName, testFunction) {\n  console.log(`\\nüß™ Testing: ${testName}`)\n  console.log('-'.repeat(50))\n  \n  try {\n    const result = testFunction()\n    if (result.success) {\n      console.log(`‚úÖ ${testName}: PASSED`)\n      if (result.details) {\n        result.details.forEach(detail => console.log(`   ‚úì ${detail}`))\n      }\n      return true\n    } else {\n      console.log(`‚ùå ${testName}: FAILED`)\n      if (result.errors) {\n        result.errors.forEach(error => console.log(`   ‚úó ${error}`))\n      }\n      return false\n    }\n  } catch (error) {\n    console.log(`‚ùå ${testName}: ERROR - ${error.message}`)\n    return false\n  }\n}\n\nfunction testEnvironmentVariables() {\n  const envLocalPath = path.join(process.cwd(), '.env.local')\n  const envProductionPath = path.join(process.cwd(), '.env.production')\n  \n  const result = { success: true, details: [], errors: [] }\n  \n  // Check if .env.local exists\n  if (!fs.existsSync(envLocalPath)) {\n    result.errors.push('.env.local file not found')\n    result.success = false\n  } else {\n    result.details.push('.env.local file exists')\n  }\n  \n  // Check environment variable size\n  if (fs.existsSync(envLocalPath)) {\n    const envContent = fs.readFileSync(envLocalPath, 'utf8')\n    const envSize = Buffer.byteLength(envContent, 'utf8')\n    \n    if (envSize > 4096) {\n      result.errors.push(`Environment variables size (${envSize} bytes) exceeds 4KB Netlify limit`)\n      result.success = false\n    } else {\n      result.details.push(`Environment variables size (${envSize} bytes) within 4KB limit`)\n    }\n  }\n  \n  // Check for optimized production env\n  if (fs.existsSync(envProductionPath)) {\n    result.details.push('Optimized .env.production file exists')\n  }\n  \n  return result\n}\n\nfunction testJsonFiles() {\n  const guidesDir = path.join(process.cwd(), 'data', 'guides')\n  const result = { success: true, details: [], errors: [] }\n  \n  if (!fs.existsSync(guidesDir)) {\n    result.errors.push('Guides directory does not exist')\n    result.success = false\n    return result\n  }\n  \n  const files = fs.readdirSync(guidesDir).filter(file => file.endsWith('.json'))\n  result.details.push(`Found ${files.length} JSON files`)\n  \n  let validFiles = 0\n  let emptyFiles = 0\n  let malformedFiles = 0\n  \n  for (const file of files) {\n    const filePath = path.join(guidesDir, file)\n    \n    try {\n      const stats = fs.statSync(filePath)\n      if (stats.size === 0) {\n        emptyFiles++\n        continue\n      }\n      \n      const content = fs.readFileSync(filePath, 'utf8')\n      if (!content.trim()) {\n        emptyFiles++\n        continue\n      }\n      \n      const parsed = JSON.parse(content)\n      if (parsed && typeof parsed === 'object' && parsed.slug && parsed.title) {\n        validFiles++\n      } else {\n        malformedFiles++\n      }\n    } catch (error) {\n      malformedFiles++\n    }\n  }\n  \n  result.details.push(`Valid files: ${validFiles}`)\n  \n  if (emptyFiles > 0) {\n    result.errors.push(`Empty files: ${emptyFiles}`)\n    result.success = false\n  }\n  \n  if (malformedFiles > 0) {\n    result.errors.push(`Malformed files: ${malformedFiles}`)\n    result.success = false\n  }\n  \n  return result\n}\n\nfunction testBuildConfiguration() {\n  const result = { success: true, details: [], errors: [] }\n  \n  // Check critical config files\n  const configFiles = [\n    { file: 'next.config.js', required: true },\n    { file: 'netlify.toml', required: true },\n    { file: 'package.json', required: true }\n  ]\n  \n  for (const { file, required } of configFiles) {\n    const filePath = path.join(process.cwd(), file)\n    if (fs.existsSync(filePath)) {\n      result.details.push(`${file} exists`)\n      \n      // Check netlify.toml for JSON validation\n      if (file === 'netlify.toml') {\n        const content = fs.readFileSync(filePath, 'utf8')\n        if (content.includes('validate-json-guides.js')) {\n          result.details.push('JSON validation included in build command')\n        } else {\n          result.errors.push('JSON validation missing from build command')\n          result.success = false\n        }\n      }\n    } else if (required) {\n      result.errors.push(`Required file ${file} is missing`)\n      result.success = false\n    }\n  }\n  \n  return result\n}\n\nfunction testValidationScripts() {\n  const result = { success: true, details: [], errors: [] }\n  \n  const scripts = [\n    'scripts/validate-json-guides.js',\n    'scripts/validate-content-manager-json.js',\n    'scripts/optimize-env-variables.js',\n    'scripts/repair-json-files.js'\n  ]\n  \n  for (const script of scripts) {\n    const scriptPath = path.join(process.cwd(), script)\n    if (fs.existsSync(scriptPath)) {\n      result.details.push(`${script} exists`)\n      \n      // Test if script is executable\n      try {\n        const content = fs.readFileSync(scriptPath, 'utf8')\n        if (content.includes('#!/usr/bin/env node')) {\n          result.details.push(`${script} is properly configured`)\n        }\n      } catch (error) {\n        result.errors.push(`Cannot read ${script}: ${error.message}`)\n        result.success = false\n      }\n    } else {\n      result.errors.push(`Required script ${script} is missing`)\n      result.success = false\n    }\n  }\n  \n  return result\n}\n\nfunction testNetlifyFunctions() {\n  const result = { success: true, details: [], errors: [] }\n  \n  const functionsDir = path.join(process.cwd(), 'netlify', 'functions')\n  const pagesApiDir = path.join(process.cwd(), 'pages', 'api')\n  \n  // Check if API routes exist\n  if (fs.existsSync(pagesApiDir)) {\n    const apiFiles = fs.readdirSync(pagesApiDir, { recursive: true })\n      .filter(file => file.endsWith('.ts') || file.endsWith('.js'))\n    \n    result.details.push(`Found ${apiFiles.length} API routes`)\n    \n    // Check for critical API files mentioned in error logs\n    const criticalApis = [\n      'health.ts',\n      'analyze.ts',\n      'guides.ts'\n    ]\n    \n    for (const api of criticalApis) {\n      if (apiFiles.includes(api)) {\n        result.details.push(`Critical API ${api} exists`)\n      } else {\n        result.errors.push(`Critical API ${api} is missing`)\n        result.success = false\n      }\n    }\n  } else {\n    result.errors.push('Pages API directory does not exist')\n    result.success = false\n  }\n  \n  return result\n}\n\nfunction testPackageJson() {\n  const result = { success: true, details: [], errors: [] }\n  \n  const packagePath = path.join(process.cwd(), 'package.json')\n  \n  if (!fs.existsSync(packagePath)) {\n    result.errors.push('package.json does not exist')\n    result.success = false\n    return result\n  }\n  \n  try {\n    const packageContent = fs.readFileSync(packagePath, 'utf8')\n    const packageJson = JSON.parse(packageContent)\n    \n    // Check for required scripts\n    const requiredScripts = ['build', 'dev', 'start']\n    for (const script of requiredScripts) {\n      if (packageJson.scripts && packageJson.scripts[script]) {\n        result.details.push(`Script '${script}' exists`)\n      } else {\n        result.errors.push(`Required script '${script}' is missing`)\n        result.success = false\n      }\n    }\n    \n    // Check for validation scripts\n    if (packageJson.scripts && packageJson.scripts['validate:guides']) {\n      result.details.push('JSON validation script configured')\n    }\n    \n    // Check for critical dependencies\n    const criticalDeps = ['next', 'react', 'typescript']\n    for (const dep of criticalDeps) {\n      if (packageJson.dependencies && packageJson.dependencies[dep]) {\n        result.details.push(`Dependency '${dep}' exists`)\n      } else {\n        result.errors.push(`Critical dependency '${dep}' is missing`)\n        result.success = false\n      }\n    }\n    \n  } catch (error) {\n    result.errors.push(`Cannot parse package.json: ${error.message}`)\n    result.success = false\n  }\n  \n  return result\n}\n\nfunction testBuildProcess() {\n  const result = { success: true, details: [], errors: [] }\n  \n  try {\n    // Test JSON validation\n    console.log('   Running JSON validation...')\n    execSync('node scripts/validate-json-guides.js', { stdio: 'pipe' })\n    result.details.push('JSON validation passed')\n    \n    // Test environment optimization\n    console.log('   Testing environment optimization...')\n    execSync('node scripts/optimize-env-variables.js', { stdio: 'pipe' })\n    result.details.push('Environment optimization completed')\n    \n    // Test JSON repair\n    console.log('   Testing JSON repair...')\n    execSync('node scripts/repair-json-files.js', { stdio: 'pipe' })\n    result.details.push('JSON repair completed')\n    \n  } catch (error) {\n    result.errors.push(`Build process test failed: ${error.message}`)\n    result.success = false\n  }\n  \n  return result\n}\n\nfunction runComprehensiveTests() {\n  console.log('üöÄ BLAKE\\'S COMPREHENSIVE DEPLOYMENT TESTING PROTOCOL')\n  console.log('=' .repeat(60))\n  \n  const tests = [\n    { name: 'Environment Variables', test: testEnvironmentVariables },\n    { name: 'JSON Files Integrity', test: testJsonFiles },\n    { name: 'Build Configuration', test: testBuildConfiguration },\n    { name: 'Validation Scripts', test: testValidationScripts },\n    { name: 'Netlify Functions', test: testNetlifyFunctions },\n    { name: 'Package Configuration', test: testPackageJson },\n    { name: 'Build Process', test: testBuildProcess }\n  ]\n  \n  let passedTests = 0\n  let totalTests = tests.length\n  \n  for (const { name, test } of tests) {\n    if (runTest(name, test)) {\n      passedTests++\n    }\n  }\n  \n  console.log('\\n' + '=' .repeat(60))\n  console.log('üìä DEPLOYMENT TESTING SUMMARY')\n  console.log('=' .repeat(60))\n  console.log(`Tests Passed: ${passedTests}/${totalTests}`)\n  console.log(`Success Rate: ${Math.round((passedTests / totalTests) * 100)}%`)\n  \n  if (passedTests === totalTests) {\n    console.log('\\n‚úÖ ALL TESTS PASSED - DEPLOYMENT READY!')\n    console.log('üöÄ Netlify deployment should succeed')\n    console.log('\\nüìã Deployment Checklist:')\n    console.log('   ‚úì Environment variables optimized')\n    console.log('   ‚úì JSON files validated and repaired')\n    console.log('   ‚úì Build configuration verified')\n    console.log('   ‚úì Validation scripts ready')\n    console.log('   ‚úì API functions configured')\n    console.log('   ‚úì Package dependencies verified')\n    console.log('   ‚úì Build process tested')\n    \n    return true\n  } else {\n    console.log('\\n‚ùå SOME TESTS FAILED - DEPLOYMENT NOT READY')\n    console.log('   Please fix the issues above before deploying')\n    \n    return false\n  }\n}\n\n// Run tests if called directly\nif (require.main === module) {\n  const success = runComprehensiveTests()\n  process.exit(success ? 0 : 1)\n}\n\nmodule.exports = {\n  runComprehensiveTests,\n  testEnvironmentVariables,\n  testJsonFiles,\n  testBuildConfiguration,\n  testValidationScripts,\n  testNetlifyFunctions,\n  testPackageJson,\n  testBuildProcess\n}"