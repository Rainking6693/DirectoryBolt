#!/usr/bin/env node

/**
 * SECURITY VULNERABILITY VALIDATION SUITE
 * =======================================
 * 
 * Validates Hudson's critical security audit fixes:
 * - Environment file security (git tracking removal)
 * - API key security (hardcoded fallback removal)
 * - CORS configuration security
 * - Deployment conflict resolution
 * - Information leakage prevention
 * - Access control validation
 * 
 * This suite ensures all security vulnerabilities identified by Hudson are resolved.
 */

const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');
const util = require('util');
const execAsync = util.promisify(exec);

class SecurityVulnerabilityValidation {
    constructor() {
        this.baseUrl = process.env.TEST_BASE_URL || 'http://localhost:3000';
        this.testResults = {
            timestamp: new Date().toISOString(),
            environment: process.env.NODE_ENV || 'development',
            criticalVulnerabilities: {
                environmentFileSecurity: null,
                apiKeySecurity: null,
                corsConfiguration: null,
                deploymentConflicts: null,
                informationLeakage: null,
                accessControl: null
            },
            securityScore: 0,
            vulnerabilitiesFound: [],
            vulnerabilitiesFixed: [],
            recommendations: []
        };
    }

    // ===============================================
    // CRITICAL VULNERABILITY TESTS
    // ===============================================

    async validateEnvironmentFileSecurity() {
        console.log('\n🔒 VALIDATING ENVIRONMENT FILE SECURITY');
        console.log('======================================');
        
        const tests = [
            this.testGitIgnoreConfiguration.bind(this),
            this.testEnvironmentFileTracking.bind(this),
            this.testEnvironmentFileExposure.bind(this)
        ];

        let results = [];
        for (const test of tests) {
            try {
                const result = await test();
                results.push(result);
                this.logSecurityTest(result);
            } catch (error) {
                results.push({
                    passed: false,
                    test: 'Environment File Security',
                    vulnerability: 'CRITICAL',
                    error: error.message
                });
            }
        }

        const passedTests = results.filter(r => r.passed).length;
        const score = (passedTests / results.length) * 10;
        
        this.testResults.criticalVulnerabilities.environmentFileSecurity = {
            score: score,
            tests: results,
            status: score >= 8 ? 'SECURE' : 'VULNERABLE'
        };

        return score;
    }

    async testGitIgnoreConfiguration() {
        // Check .gitignore has comprehensive environment file blocking
        if (!fs.existsSync('.gitignore')) {
            return {
                passed: false,
                test: 'GitIgnore Configuration',
                vulnerability: 'CRITICAL',
                issue: '.gitignore file missing'
            };
        }

        const gitignoreContent = fs.readFileSync('.gitignore', 'utf8');
        
        const requiredPatterns = [
            '.env',
            '.env.local', 
            '.env.development',
            '.env.production',
            '.env.staging',
            '.env*.local'
        ];

        const missingPatterns = requiredPatterns.filter(pattern => 
            !gitignoreContent.includes(pattern)
        );

        // Check for comprehensive blocking
        const hasWildcardPattern = gitignoreContent.includes('.env*');
        const hasSpecificPatterns = requiredPatterns.some(pattern => 
            gitignoreContent.includes(pattern)
        );

        return {
            passed: missingPatterns.length === 0 && (hasWildcardPattern || hasSpecificPatterns),
            test: 'GitIgnore Environment Configuration',
            vulnerability: missingPatterns.length > 0 ? 'CRITICAL' : 'NONE',
            details: {
                missingPatterns,
                hasWildcardPattern,
                patternsFound: requiredPatterns.filter(p => gitignoreContent.includes(p)).length
            }
        };
    }

    async testEnvironmentFileTracking() {
        // Check if any environment files are tracked in git
        try {
            const { stdout } = await execAsync('git ls-files | grep -E "\\.env"');
            
            // If we get output, environment files are tracked (BAD)
            const trackedFiles = stdout.trim().split('\n').filter(file => file);
            
            return {
                passed: trackedFiles.length === 0 || !stdout.trim(),
                test: 'Environment File Git Tracking',
                vulnerability: trackedFiles.length > 0 ? 'CRITICAL' : 'NONE',
                details: {
                    trackedFiles: trackedFiles.length > 0 ? trackedFiles : 'None (Good)',
                    message: trackedFiles.length > 0 ? 
                        'Environment files are being tracked in git!' : 
                        'No environment files tracked in git'
                }
            };
        } catch (error) {
            // No environment files found in git (GOOD)
            return {
                passed: true,
                test: 'Environment File Git Tracking',
                vulnerability: 'NONE',
                details: {
                    trackedFiles: 'None (Good)',
                    message: 'No environment files tracked in git'
                }
            };
        }
    }

    async testEnvironmentFileExposure() {
        // Check for environment files that exist but shouldn't be public
        const environmentFiles = [
            '.env',
            '.env.local',
            '.env.development',
            '.env.production'
        ];

        let exposedFiles = [];
        let filesWithSecrets = [];

        for (const file of environmentFiles) {
            if (fs.existsSync(file)) {
                exposedFiles.push(file);
                
                const content = fs.readFileSync(file, 'utf8');
                
                // Check for actual secrets (not placeholders)
                const hasRealSecrets = content.includes('sk_live_') || 
                    content.includes('whsec_1') ||
                    (content.includes('sk_test_') && !content.includes('mock') && !content.includes('placeholder'));

                if (hasRealSecrets) {
                    filesWithSecrets.push(file);
                }
            }
        }

        return {
            passed: filesWithSecrets.length === 0,
            test: 'Environment File Exposure',
            vulnerability: filesWithSecrets.length > 0 ? 'CRITICAL' : (exposedFiles.length > 0 ? 'MEDIUM' : 'NONE'),
            details: {
                exposedFiles,
                filesWithSecrets,
                recommendation: exposedFiles.length > 0 ? 'Remove exposed environment files from working directory' : 'Good'
            }
        };
    }

    async validateApiKeySecurity() {
        console.log('\n🔑 VALIDATING API KEY SECURITY');
        console.log('=============================');
        
        const tests = [
            this.testHardcodedSecretRemoval.bind(this),
            this.testSecretKeyAccess.bind(this),
            this.testFallbackKeyRemoval.bind(this)
        ];

        let results = [];
        for (const test of tests) {
            try {
                const result = await test();
                results.push(result);
                this.logSecurityTest(result);
            } catch (error) {
                results.push({
                    passed: false,
                    test: 'API Key Security',
                    vulnerability: 'CRITICAL',
                    error: error.message
                });
            }
        }

        const passedTests = results.filter(r => r.passed).length;
        const score = (passedTests / results.length) * 10;
        
        this.testResults.criticalVulnerabilities.apiKeySecurity = {
            score: score,
            tests: results,
            status: score >= 8 ? 'SECURE' : 'VULNERABLE'
        };

        return score;
    }

    async testHardcodedSecretRemoval() {
        // Scan critical files for hardcoded secrets
        const criticalFiles = [
            'pages/api/create-checkout-session.js',
            'pages/api/webhooks/stripe.js',
            'lib/utils/stripe-client.ts',
            'next.config.js'
        ];

        let secretFindings = [];

        for (const file of criticalFiles) {
            if (fs.existsSync(file)) {
                const content = fs.readFileSync(file, 'utf8');
                
                // Look for hardcoded secrets
                const secretPatterns = [
                    { pattern: 'sk_test_mock_key_for_testing', type: 'Mock Key Fallback' },
                    { pattern: /sk_live_[a-zA-Z0-9]{24,}/, type: 'Live Secret Key' },
                    { pattern: /sk_test_[a-zA-Z0-9]{24,}/, type: 'Test Secret Key' },
                    { pattern: /whsec_[a-zA-Z0-9]{32,}/, type: 'Webhook Secret' },
                    { pattern: /rk_test_[a-zA-Z0-9]{24,}/, type: 'Restricted Key' }
                ];

                for (const { pattern, type } of secretPatterns) {
                    const matches = typeof pattern === 'string' ? 
                        content.includes(pattern) : 
                        pattern.test(content);

                    if (matches) {
                        // Check if it's in a comment or marked as removed
                        const lines = content.split('\n');
                        const matchingLines = lines.filter(line => {
                            const hasPattern = typeof pattern === 'string' ? 
                                line.includes(pattern) : 
                                pattern.test(line);
                            return hasPattern;
                        });

                        const isInComment = matchingLines.every(line => 
                            line.trim().startsWith('//') || 
                            line.includes('removed') ||
                            line.includes('placeholder') ||
                            line.includes('example')
                        );

                        if (!isInComment) {
                            secretFindings.push({
                                file,
                                type,
                                severity: type.includes('Live') ? 'CRITICAL' : 'HIGH'
                            });
                        }
                    }
                }
            }
        }

        return {
            passed: secretFindings.length === 0,
            test: 'Hardcoded Secret Removal',
            vulnerability: secretFindings.length > 0 ? 'CRITICAL' : 'NONE',
            details: {
                secretsFound: secretFindings.length,
                findings: secretFindings,
                filesScanned: criticalFiles.length
            }
        };
    }

    async testSecretKeyAccess() {
        // Test that secret keys are only accessed server-side
        const clientSideFiles = [
            'components/**/*.tsx',
            'components/**/*.jsx',
            'pages/index.tsx',
            'pages/pricing.tsx'
        ];

        let violations = [];

        // Simple file globbing
        const clientFiles = [];
        const scanDirectory = (dir, pattern) => {
            if (!fs.existsSync(dir)) return;
            
            const items = fs.readdirSync(dir, { withFileTypes: true });
            for (const item of items) {
                const fullPath = path.join(dir, item.name);
                if (item.isDirectory()) {
                    scanDirectory(fullPath, pattern);
                } else if (item.name.match(/\.(tsx|jsx)$/)) {
                    clientFiles.push(fullPath);
                }
            }
        };

        scanDirectory('components', /\.(tsx|jsx)$/);
        if (fs.existsSync('pages/index.tsx')) clientFiles.push('pages/index.tsx');
        if (fs.existsSync('pages/pricing.tsx')) clientFiles.push('pages/pricing.tsx');

        const serverOnlyPatterns = [
            'STRIPE_SECRET_KEY',
            'STRIPE_WEBHOOK_SECRET',
            'process.env.STRIPE_SECRET'
        ];

        for (const file of clientFiles) {
            const content = fs.readFileSync(file, 'utf8');
            
            for (const pattern of serverOnlyPatterns) {
                if (content.includes(pattern)) {
                    violations.push({
                        file: file,
                        pattern: pattern,
                        severity: 'CRITICAL'
                    });
                }
            }
        }

        return {
            passed: violations.length === 0,
            test: 'Secret Key Access Control',
            vulnerability: violations.length > 0 ? 'CRITICAL' : 'NONE',
            details: {
                violations,
                clientFilesScanned: clientFiles.length,
                serverOnlyPatterns
            }
        };
    }

    async testFallbackKeyRemoval() {
        // Check that fallback keys are properly removed
        const apiFiles = [
            'pages/api/create-checkout-session.js',
            'lib/utils/stripe-client.ts'
        ];

        let fallbackFindings = [];

        for (const file of apiFiles) {
            if (fs.existsSync(file)) {
                const content = fs.readFileSync(file, 'utf8');
                
                // Look for fallback patterns
                const fallbackPatterns = [
                    'sk_test_mock_key_for_testing',
                    '|| \'sk_',
                    'process.env.STRIPE_SECRET_KEY || \'',
                    'fallback',
                    'default_key'
                ];

                for (const pattern of fallbackPatterns) {
                    if (content.includes(pattern)) {
                        // Check if it's been properly removed (commented out or in error message)
                        const lines = content.split('\n');
                        const matchingLines = lines.filter(line => line.includes(pattern));
                        
                        const isProperlyRemoved = matchingLines.every(line => 
                            line.trim().startsWith('//') || 
                            line.includes('removed') ||
                            line.includes('error') ||
                            line.includes('throw')
                        );

                        if (!isProperlyRemoved) {
                            fallbackFindings.push({
                                file,
                                pattern,
                                severity: 'HIGH'
                            });
                        }
                    }
                }
            }
        }

        return {
            passed: fallbackFindings.length === 0,
            test: 'Fallback Key Removal',
            vulnerability: fallbackFindings.length > 0 ? 'HIGH' : 'NONE',
            details: {
                fallbacksFound: fallbackFindings.length,
                findings: fallbackFindings,
                filesScanned: apiFiles.length
            }
        };
    }

    async validateCorsConfiguration() {
        console.log('\n🌐 VALIDATING CORS CONFIGURATION');
        console.log('===============================');
        
        const result = await this.testCorsRestriction();
        this.logSecurityTest(result);
        
        const score = result.passed ? 10 : 0;
        this.testResults.criticalVulnerabilities.corsConfiguration = {
            score: score,
            test: result,
            status: score >= 8 ? 'SECURE' : 'VULNERABLE'
        };

        return score;
    }

    async testCorsRestriction() {
        const nextConfigPath = 'next.config.js';
        
        if (!fs.existsSync(nextConfigPath)) {
            return {
                passed: false,
                test: 'CORS Configuration',
                vulnerability: 'HIGH',
                issue: 'next.config.js not found'
            };
        }

        const content = fs.readFileSync(nextConfigPath, 'utf8');
        
        // Check for wildcard CORS (BAD)
        const hasWildcardCors = content.includes('origin: "*"') || 
                               content.includes("origin: '*'") ||
                               content.includes('Access-Control-Allow-Origin": "*');
        
        // Check for environment-specific CORS (GOOD)
        const hasEnvironmentCors = content.includes('process.env.NODE_ENV') && 
                                  (content.includes('localhost') || content.includes('directorybolt.com'));
        
        // Check for specific domain restrictions
        const hasSpecificDomains = content.includes('directorybolt.com') || 
                                  content.includes('localhost:3000');

        return {
            passed: !hasWildcardCors && (hasEnvironmentCors || hasSpecificDomains),
            test: 'CORS Restriction',
            vulnerability: hasWildcardCors ? 'CRITICAL' : 'NONE',
            details: {
                hasWildcardCors,
                hasEnvironmentCors,
                hasSpecificDomains,
                recommendation: hasWildcardCors ? 
                    'Remove wildcard CORS and implement environment-specific origins' : 
                    'CORS properly restricted'
            }
        };
    }

    async validateDeploymentConflicts() {
        console.log('\n🚀 VALIDATING DEPLOYMENT SECURITY');
        console.log('===============================');
        
        const tests = [
            this.testVercelArtifactRemoval.bind(this),
            this.testDeploymentConfiguration.bind(this)
        ];

        let results = [];
        for (const test of tests) {
            try {
                const result = await test();
                results.push(result);
                this.logSecurityTest(result);
            } catch (error) {
                results.push({
                    passed: false,
                    test: 'Deployment Security',
                    vulnerability: 'MEDIUM',
                    error: error.message
                });
            }
        }

        const passedTests = results.filter(r => r.passed).length;
        const score = (passedTests / results.length) * 10;
        
        this.testResults.criticalVulnerabilities.deploymentConflicts = {
            score: score,
            tests: results,
            status: score >= 8 ? 'SECURE' : 'VULNERABLE'
        };

        return score;
    }

    async testVercelArtifactRemoval() {
        // Check that Vercel artifacts were removed to prevent conflicts
        const vercelArtifacts = [
            'vercel.json',
            '.vercel/',
            '.vercel'
        ];

        let foundArtifacts = [];
        for (const artifact of vercelArtifacts) {
            if (fs.existsSync(artifact)) {
                foundArtifacts.push(artifact);
            }
        }

        return {
            passed: foundArtifacts.length === 0,
            test: 'Vercel Artifact Removal',
            vulnerability: foundArtifacts.length > 0 ? 'MEDIUM' : 'NONE',
            details: {
                artifactsFound: foundArtifacts,
                recommendation: foundArtifacts.length > 0 ? 
                    'Remove Vercel artifacts to prevent deployment conflicts' : 
                    'Clean deployment configuration'
            }
        };
    }

    async testDeploymentConfiguration() {
        // Check for clean deployment configuration
        const deploymentFiles = [
            'netlify.toml',
            'package.json'
        ];

        let configurationIssues = [];

        for (const file of deploymentFiles) {
            if (fs.existsSync(file)) {
                const content = fs.readFileSync(file, 'utf8');
                
                if (file === 'package.json') {
                    const packageJson = JSON.parse(content);
                    
                    // Check for conflicting deployment scripts
                    const scripts = packageJson.scripts || {};
                    const hasVercelScript = Object.values(scripts).some(script => 
                        script.includes('vercel')
                    );
                    const hasNetlifyScript = Object.values(scripts).some(script => 
                        script.includes('netlify')
                    );

                    if (hasVercelScript && hasNetlifyScript) {
                        configurationIssues.push({
                            file,
                            issue: 'Conflicting deployment scripts (Vercel and Netlify)'
                        });
                    }
                }
            }
        }

        return {
            passed: configurationIssues.length === 0,
            test: 'Deployment Configuration',
            vulnerability: configurationIssues.length > 0 ? 'MEDIUM' : 'NONE',
            details: {
                issues: configurationIssues,
                filesChecked: deploymentFiles.length
            }
        };
    }

    async validateInformationLeakage() {
        console.log('\n🔍 VALIDATING INFORMATION LEAKAGE PREVENTION');
        console.log('============================================');
        
        const tests = [
            this.testApiResponseSecurity.bind(this),
            this.testErrorMessageSecurity.bind(this),
            this.testLoggingSecurity.bind(this)
        ];

        let results = [];
        for (const test of tests) {
            try {
                const result = await test();
                results.push(result);
                this.logSecurityTest(result);
            } catch (error) {
                results.push({
                    passed: false,
                    test: 'Information Leakage',
                    vulnerability: 'HIGH',
                    error: error.message
                });
            }
        }

        const passedTests = results.filter(r => r.passed).length;
        const score = (passedTests / results.length) * 10;
        
        this.testResults.criticalVulnerabilities.informationLeakage = {
            score: score,
            tests: results,
            status: score >= 8 ? 'SECURE' : 'VULNERABLE'
        };

        return score;
    }

    async testApiResponseSecurity() {
        // Test API endpoints for information leakage
        const testEndpoints = [
            { path: '/api/health', method: 'GET' },
            { path: '/api/create-checkout-session', method: 'POST', body: { invalid: 'data' } }
        ];

        let leakageFindings = [];

        for (const endpoint of testEndpoints) {
            try {
                const options = {
                    method: endpoint.method,
                    headers: { 'Content-Type': 'application/json' }
                };

                if (endpoint.body) {
                    options.body = JSON.stringify(endpoint.body);
                }

                const response = await fetch(`${this.baseUrl}${endpoint.path}`, options);
                const text = await response.text();

                // Check for leaked sensitive information
                const sensitivePatterns = [
                    'sk_',
                    'whsec_',
                    'rk_test_',
                    'password',
                    'secret',
                    'token',
                    'key',
                    'STRIPE_SECRET',
                    'process.env'
                ];

                for (const pattern of sensitivePatterns) {
                    if (text.includes(pattern)) {
                        leakageFindings.push({
                            endpoint: endpoint.path,
                            pattern,
                            severity: pattern.includes('sk_') || pattern.includes('secret') ? 'CRITICAL' : 'MEDIUM'
                        });
                    }
                }

            } catch (error) {
                // Network errors are acceptable for this test
            }
        }

        return {
            passed: leakageFindings.length === 0,
            test: 'API Response Security',
            vulnerability: leakageFindings.length > 0 ? 'CRITICAL' : 'NONE',
            details: {
                leakageFound: leakageFindings.length,
                findings: leakageFindings,
                endpointsTested: testEndpoints.length
            }
        };
    }

    async testErrorMessageSecurity() {
        // Check that error messages don't expose sensitive information
        const apiFiles = [
            'pages/api/create-checkout-session.js',
            'pages/api/webhooks/stripe.js'
        ];

        let securityIssues = [];

        for (const file of apiFiles) {
            if (fs.existsSync(file)) {
                const content = fs.readFileSync(file, 'utf8');
                
                // Look for error handling that might expose secrets
                const lines = content.split('\n');
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    
                    // Check for error responses that might leak information
                    if (line.includes('res.json') && line.includes('error')) {
                        // Look for potential information leakage in error responses
                        if (line.includes('e.message') || line.includes('error.message')) {
                            // Raw error messages can leak sensitive information
                            const hasProperSanitization = lines.slice(Math.max(0, i-5), i+5).some(l => 
                                l.includes('sanitize') || l.includes('safe') || l.includes('user-friendly')
                            );

                            if (!hasProperSanitization) {
                                securityIssues.push({
                                    file,
                                    line: i + 1,
                                    issue: 'Raw error message exposure',
                                    severity: 'MEDIUM'
                                });
                            }
                        }
                    }
                }
            }
        }

        return {
            passed: securityIssues.length === 0,
            test: 'Error Message Security',
            vulnerability: securityIssues.length > 0 ? 'MEDIUM' : 'NONE',
            details: {
                issuesFound: securityIssues.length,
                issues: securityIssues,
                recommendation: 'Sanitize error messages before sending to client'
            }
        };
    }

    async testLoggingSecurity() {
        // Check logging implementation for security
        const loggerPath = 'lib/utils/logger.ts';
        
        if (!fs.existsSync(loggerPath)) {
            return {
                passed: false,
                test: 'Logging Security',
                vulnerability: 'MEDIUM',
                issue: 'Logger utility not found'
            };
        }

        const content = fs.readFileSync(loggerPath, 'utf8');
        
        // Check for secure logging practices
        const hasProductionLogging = content.includes('NODE_ENV') && content.includes('production');
        const hasSanitization = content.includes('sanitiz') || content.includes('redact') || content.includes('mask');
        const hasSecretFiltering = content.includes('sk_') || content.includes('secret') || content.includes('filter');

        return {
            passed: hasProductionLogging && (hasSanitization || hasSecretFiltering),
            test: 'Logging Security',
            vulnerability: !hasProductionLogging ? 'MEDIUM' : 'NONE',
            details: {
                hasProductionLogging,
                hasSanitization,
                hasSecretFiltering,
                recommendation: !hasProductionLogging ? 
                    'Implement production-specific logging behavior' : 
                    'Logging security appears adequate'
            }
        };
    }

    async validateAccessControl() {
        console.log('\n🛡️ VALIDATING ACCESS CONTROL');
        console.log('===========================');
        
        const tests = [
            this.testApiRouteProtection.bind(this),
            this.testMethodValidation.bind(this),
            this.testInputValidation.bind(this)
        ];

        let results = [];
        for (const test of tests) {
            try {
                const result = await test();
                results.push(result);
                this.logSecurityTest(result);
            } catch (error) {
                results.push({
                    passed: false,
                    test: 'Access Control',
                    vulnerability: 'HIGH',
                    error: error.message
                });
            }
        }

        const passedTests = results.filter(r => r.passed).length;
        const score = (passedTests / results.length) * 10;
        
        this.testResults.criticalVulnerabilities.accessControl = {
            score: score,
            tests: results,
            status: score >= 8 ? 'SECURE' : 'VULNERABLE'
        };

        return score;
    }

    async testApiRouteProtection() {
        // Check API routes have proper protection
        const apiRoutes = [
            'pages/api/create-checkout-session.js',
            'pages/api/webhooks/stripe.js'
        ];

        let protectionAnalysis = [];

        for (const route of apiRoutes) {
            if (fs.existsSync(route)) {
                const content = fs.readFileSync(route, 'utf8');
                
                const hasMethodChecking = content.includes('req.method') || 
                                        content.includes('GET') || 
                                        content.includes('POST');
                                        
                const hasInputValidation = content.includes('validate') || 
                                         content.includes('check') || 
                                         content.includes('verify');
                                         
                const hasErrorHandling = content.includes('try') && content.includes('catch');
                
                protectionAnalysis.push({
                    route: route,
                    hasMethodChecking,
                    hasInputValidation,
                    hasErrorHandling,
                    score: [hasMethodChecking, hasInputValidation, hasErrorHandling].filter(Boolean).length
                });
            }
        }

        const averageScore = protectionAnalysis.length > 0 ? 
            protectionAnalysis.reduce((sum, route) => sum + route.score, 0) / (protectionAnalysis.length * 3) : 0;

        return {
            passed: averageScore >= 0.7, // 70% threshold
            test: 'API Route Protection',
            vulnerability: averageScore < 0.5 ? 'HIGH' : (averageScore < 0.7 ? 'MEDIUM' : 'NONE'),
            details: {
                routesAnalyzed: protectionAnalysis.length,
                averageScore: averageScore,
                analysis: protectionAnalysis
            }
        };
    }

    async testMethodValidation() {
        // Test HTTP method validation
        const testCases = [
            { path: '/api/create-checkout-session', method: 'GET', shouldFail: true },
            { path: '/api/webhooks/stripe', method: 'GET', shouldFail: true },
            { path: '/api/health', method: 'POST', shouldFail: false } // Health might accept both
        ];

        let validationResults = [];

        for (const testCase of testCases) {
            try {
                const response = await fetch(`${this.baseUrl}${testCase.path}`, {
                    method: testCase.method
                });

                const shouldHaveRejected = testCase.shouldFail && response.status === 405; // Method Not Allowed
                const shouldHaveAccepted = !testCase.shouldFail && response.status < 400;

                validationResults.push({
                    path: testCase.path,
                    method: testCase.method,
                    status: response.status,
                    properlyHandled: shouldHaveRejected || shouldHaveAccepted,
                    expected: testCase.shouldFail ? 'rejection' : 'acceptance'
                });

            } catch (error) {
                validationResults.push({
                    path: testCase.path,
                    method: testCase.method,
                    error: error.message
                });
            }
        }

        const properlyHandled = validationResults.filter(r => r.properlyHandled).length;

        return {
            passed: properlyHandled >= Math.floor(validationResults.length * 0.7),
            test: 'HTTP Method Validation',
            vulnerability: properlyHandled < validationResults.length * 0.5 ? 'MEDIUM' : 'NONE',
            details: {
                testsRun: validationResults.length,
                properlyHandled,
                results: validationResults
            }
        };
    }

    async testInputValidation() {
        // Test input validation in API routes
        const validationTests = [
            {
                endpoint: '/api/create-checkout-session',
                payload: { maliciousScript: '<script>alert("xss")</script>' },
                expectedBehavior: 'reject'
            },
            {
                endpoint: '/api/create-checkout-session',
                payload: { sqlInjection: "'; DROP TABLE users; --" },
                expectedBehavior: 'reject'
            }
        ];

        let validationResults = [];

        for (const test of validationTests) {
            try {
                const response = await fetch(`${this.baseUrl}${test.endpoint}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(test.payload)
                });

                const data = await response.text();
                
                // Check that malicious input was rejected (not echoed back)
                const inputReflected = Object.values(test.payload).some(value => 
                    data.includes(value)
                );

                validationResults.push({
                    endpoint: test.endpoint,
                    inputType: Object.keys(test.payload)[0],
                    status: response.status,
                    inputReflected,
                    safelyHandled: !inputReflected && response.status >= 400
                });

            } catch (error) {
                validationResults.push({
                    endpoint: test.endpoint,
                    error: error.message
                });
            }
        }

        const safelyHandled = validationResults.filter(r => r.safelyHandled).length;

        return {
            passed: safelyHandled >= Math.floor(validationResults.length * 0.8),
            test: 'Input Validation',
            vulnerability: safelyHandled < validationResults.length * 0.6 ? 'HIGH' : 'NONE',
            details: {
                testsRun: validationResults.length,
                safelyHandled,
                results: validationResults
            }
        };
    }

    // ===============================================
    // UTILITY METHODS
    // ===============================================

    logSecurityTest(result) {
        const icon = result.passed ? '✅' : '❌';
        const vuln = result.vulnerability || 'NONE';
        console.log(`  ${icon} ${result.test} [${vuln}]`);
        
        if (!result.passed && result.error) {
            console.log(`     Error: ${result.error}`);
        }
        
        if (!result.passed && result.issue) {
            console.log(`     Issue: ${result.issue}`);
        }

        // Track vulnerabilities
        if (!result.passed) {
            this.testResults.vulnerabilitiesFound.push({
                test: result.test,
                vulnerability: result.vulnerability || 'UNKNOWN',
                issue: result.issue || result.error || 'Security test failed'
            });
        } else {
            this.testResults.vulnerabilitiesFixed.push({
                test: result.test,
                description: 'Security vulnerability successfully resolved'
            });
        }
    }

    // ===============================================
    // MAIN EXECUTION
    // ===============================================

    async runSecurityValidation() {
        console.log('🛡️ SECURITY VULNERABILITY VALIDATION SUITE');
        console.log('==========================================');
        console.log(`Testing Environment: ${this.testResults.environment}`);
        console.log(`Base URL: ${this.baseUrl}`);
        console.log(`Timestamp: ${this.testResults.timestamp}`);
        console.log();

        try {
            // Run all security validation categories
            const scores = {
                environmentSecurity: await this.validateEnvironmentFileSecurity(),
                apiKeySecurity: await this.validateApiKeySecurity(),
                corsConfiguration: await this.validateCorsConfiguration(),
                deploymentConflicts: await this.validateDeploymentConflicts(),
                informationLeakage: await this.validateInformationLeakage(),
                accessControl: await this.validateAccessControl()
            };

            // Calculate overall security score
            const totalScore = Object.values(scores).reduce((sum, score) => sum + score, 0);
            this.testResults.securityScore = totalScore / Object.keys(scores).length;

            this.generateSecurityReport(scores);
            await this.saveSecurityResults();

        } catch (error) {
            console.error('❌ Security validation suite failed:', error.message);
            this.testResults.vulnerabilitiesFound.push({
                test: 'Overall Security Suite',
                vulnerability: 'CRITICAL',
                issue: error.message
            });
        }

        return this.testResults;
    }

    generateSecurityReport(scores) {
        console.log('\n🔒 SECURITY VULNERABILITY VALIDATION SUMMARY');
        console.log('============================================');
        
        // Category scores
        Object.entries(scores).forEach(([category, score]) => {
            const status = score >= 8 ? '🟢 SECURE' : score >= 6 ? '🟡 NEEDS ATTENTION' : '🔴 VULNERABLE';
            console.log(`${category}: ${score.toFixed(1)}/10 ${status}`);
        });
        
        console.log(`\n🎯 Overall Security Score: ${this.testResults.securityScore.toFixed(1)}/10`);
        
        // Security status
        if (this.testResults.securityScore >= 8) {
            console.log('\n✅ EXCELLENT SECURITY: All critical vulnerabilities resolved');
        } else if (this.testResults.securityScore >= 6) {
            console.log('\n⚠️  GOOD SECURITY: Minor issues need attention');
        } else {
            console.log('\n❌ SECURITY CONCERNS: Critical vulnerabilities must be addressed');
        }
        
        // Vulnerabilities found
        if (this.testResults.vulnerabilitiesFound.length > 0) {
            console.log('\n🚨 VULNERABILITIES FOUND:');
            this.testResults.vulnerabilitiesFound.forEach((vuln, i) => {
                console.log(`${i + 1}. [${vuln.vulnerability}] ${vuln.test}: ${vuln.issue}`);
            });
        }
        
        // Vulnerabilities fixed
        if (this.testResults.vulnerabilitiesFixed.length > 0) {
            console.log('\n✅ VULNERABILITIES FIXED:');
            console.log(`   ${this.testResults.vulnerabilitiesFixed.length} security issues successfully resolved`);
        }

        // Final assessment
        const isSecure = this.testResults.securityScore >= 7 && 
                        this.testResults.vulnerabilitiesFound.filter(v => v.vulnerability === 'CRITICAL').length === 0;
        
        console.log('\n🏁 SECURITY ASSESSMENT:');
        if (isSecure) {
            console.log('✅ PRODUCTION READY: Security vulnerabilities have been adequately addressed');
        } else {
            console.log('⚠️  REQUIRES ATTENTION: Address remaining vulnerabilities before production deployment');
        }
    }

    async saveSecurityResults() {
        const resultsPath = 'security_vulnerability_validation_results.json';
        const reportPath = 'SECURITY_VULNERABILITY_VALIDATION_REPORT.md';
        
        // Save JSON results
        fs.writeFileSync(resultsPath, JSON.stringify(this.testResults, null, 2));
        
        // Generate markdown report
        const markdown = this.generateSecurityMarkdown();
        fs.writeFileSync(reportPath, markdown);
        
        console.log(`\n📄 Security validation results saved:`);
        console.log(`   JSON: ${resultsPath}`);
        console.log(`   Report: ${reportPath}`);
    }

    generateSecurityMarkdown() {
        const vulnerabilitiesTable = this.testResults.vulnerabilitiesFound.length > 0 ?
            this.testResults.vulnerabilitiesFound.map((vuln, i) => 
                `${i + 1}. **[${vuln.vulnerability}]** ${vuln.test}: ${vuln.issue}`
            ).join('\n') :
            '✅ **No vulnerabilities found**';

        return `# 🛡️ SECURITY VULNERABILITY VALIDATION REPORT

## Executive Summary

**Validation Date**: ${new Date(this.testResults.timestamp).toLocaleDateString()}
**Environment**: ${this.testResults.environment}
**Overall Security Score**: ${this.testResults.securityScore.toFixed(1)}/10
**Vulnerabilities Found**: ${this.testResults.vulnerabilitiesFound.length}
**Vulnerabilities Fixed**: ${this.testResults.vulnerabilitiesFixed.length}

## 🚨 Security Vulnerabilities

${vulnerabilitiesTable}

## 🔒 Security Category Scores

${Object.entries(this.testResults.criticalVulnerabilities).map(([category, data]) => {
    if (data && data.score !== undefined) {
        return `- **${category}**: ${data.score.toFixed(1)}/10 (${data.status})`;
    }
    return `- **${category}**: Not tested`;
}).join('\n')}

## ✅ Hudson's Security Fixes Validation

This report validates the security fixes implemented by Hudson's security audit:

- **Environment File Security**: ${this.testResults.criticalVulnerabilities.environmentFileSecurity?.status || 'Not tested'}
- **API Key Security**: ${this.testResults.criticalVulnerabilities.apiKeySecurity?.status || 'Not tested'}
- **CORS Configuration**: ${this.testResults.criticalVulnerabilities.corsConfiguration?.status || 'Not tested'}
- **Deployment Conflicts**: ${this.testResults.criticalVulnerabilities.deploymentConflicts?.status || 'Not tested'}
- **Information Leakage**: ${this.testResults.criticalVulnerabilities.informationLeakage?.status || 'Not tested'}
- **Access Control**: ${this.testResults.criticalVulnerabilities.accessControl?.status || 'Not tested'}

## 🎯 Final Assessment

${this.testResults.securityScore >= 7 ? 
    '✅ **SECURE**: All critical security vulnerabilities have been successfully addressed.' :
    '⚠️ **NEEDS ATTENTION**: Critical security vulnerabilities require immediate attention.'
}

---

*Report generated by Security Vulnerability Validation Suite*
*Date: ${new Date().toISOString()}*
`;
    }
}

// Run the security validation
if (require.main === module) {
    const validator = new SecurityVulnerabilityValidation();
    validator.runSecurityValidation()
        .then(results => {
            console.log('\n✅ Security validation completed');
            const hasCriticalVulns = results.vulnerabilitiesFound.some(v => v.vulnerability === 'CRITICAL');
            process.exit(hasCriticalVulns || results.securityScore < 6 ? 1 : 0);
        })
        .catch(error => {
            console.error('\n❌ Security validation failed:', error.message);
            process.exit(1);
        });
}

module.exports = SecurityVulnerabilityValidation;