Computer Use



The Gemini 2.5 Computer Use Preview model and tool enable you to build browser control agents that interact with and automate tasks. Using screenshots, the Computer Use model can "see" a computer screen, and "act" by generating specific UI actions like mouse clicks and keyboard inputs. Similar to function calling, you need to write the client-side application code to receive and execute the Computer Use actions.



With Computer Use, you can build agents that:



Automate repetitive data entry or form filling on websites.

Perform automated testing of web applications and user flows

Conduct research across various websites (e.g., gathering product information, prices, and reviews from ecommerce sites to inform a purchase)

The easiest way to test the Gemini Computer Use model is through the reference implementation or Browserbase demo environment.



Note: As a Preview model, the Gemini 2.5 Computer Use model may be prone to errors and security vulnerabilities. We recommend supervising closely for important tasks, and that you avoid using the Computer Use model for tasks involving critical decisions, sensitive data, or actions where serious errors cannot be corrected. We encourage you to review the Safety best practices, the Prohibited Use Policy and Gemini API Additional Terms of Service.

How Computer Use works

To build a browser control agent with the Computer Use model, implement an agent loop that does the following:



Send a request to the model



Add the Computer Use tool and optionally any custom user-defined functions or excluded functions to your API request.

Prompt the Computer Use model with the user's request.

Receive the model response



The Computer Use model analyzes the user request and screenshot, and generates a response which includes a suggested function\_call representing a UI action (e.g., "click at coordinate (x,y)" or "type 'text'"). For a description of all UI actions supported by the Computer Use model, see Supported actions.

The API response may also include a safety\_decision from an internal safety system that checks the model's proposed action. This safety\_decision classifies the action as:

Regular / allowed: The action is considered safe. This may also be represented by no safety\_decision being present.

Requires confirmation (require\_confirmation): The model is about to perform an action that may be risky (e.g., clicking on an "accept cookie banner").

Execute the received action



Your client-side code receives the function\_call and any accompanying safety\_decision.

Regular / allowed: If the safety\_decision indicates regular / allowed (or if no safety\_decision is present), your client-side code can execute the specified function\_call in your target environment (e.g., a web browser).

Requires confirmation: If the safety\_decision indicates requires confirmation, your application must prompt the end-user for confirmation before executing the function\_call. If the user confirms, proceed to execute the action. If the user denies, don't execute the action.

Capture the new environment state



If the action has been executed, your client captures a new screenshot of the GUI and the current URL to send back to the Computer Use model as part of a function\_response.

If an action was blocked by the safety system or denied confirmation by the user, your application might send a different form of feedback to the model or end the interaction.

This process repeats from step 2 with the Computer Use model using the new screenshot and the ongoing goal to suggest the next action. The loop continues until the task is completed, an error occurs, or the process is terminated (e.g., due to a "block" safety response or user decision).



Computer Use

overview



How to implement Computer Use

Before building with the Computer Use model and tool you will need to set up the following:



Secure execution environment: For safety reasons, you should run your Computer Use agent in a secure and controlled environment (e.g., a sandboxed virtual machine, a container, or a dedicated browser profile with limited permissions).

Client-side action handler: You will need to implement client-side logic to execute the actions generated by the model and capture screenshots of the environment after each action.

The examples in this section use a browser as the execution environment and Playwright as the client-side action handler. To run these samples you must install the necessary dependencies and initialize a Playwright browser instance.



Install Playwright

Initialize Playwright browser instance

Sample code for extending to an Android environment is included in the Using custom user-defined functions section.



1\. Send a request to the model

Add the Computer Use tool to your API request and send a prompt to the Computer Use model that includes the user's goal. You must use the Gemini Computer Use model, gemini-2.5-computer-use-preview-10-2025. If you try to use the Computer Use tool with a different model, you will get an error.



You can also optionally add the following parameters:



Excluded actions: If there are any actions from the list of Supported UI actions that you don't want the model to take, specify these actions as excluded\_predefined\_functions.

User-defined functions: In addition to the Computer Use tool, you may want to include custom user-defined functions.

Note that there is no need to specify the display size when issuing a request; the model predicts pixel coordinates scaled to the height and width of the screen.



Python



from google import genai

from google.genai import types

from google.genai.types import Content, Part



client = genai.Client()



\# Specify predefined functions to exclude (optional)

excluded\_functions = \["drag\_and\_drop"]



generate\_content\_config = genai.types.GenerateContentConfig(

&nbsp;   tools=\[

&nbsp;       # 1. Computer Use tool with browser environment

&nbsp;       types.Tool(

&nbsp;           computer\_use=types.ComputerUse(

&nbsp;               environment=types.Environment.ENVIRONMENT\_BROWSER,

&nbsp;               # Optional: Exclude specific predefined functions

&nbsp;               excluded\_predefined\_functions=excluded\_functions

&nbsp;               )

&nbsp;             ),

&nbsp;       # 2. Optional: Custom user-defined functions

&nbsp;       #types.Tool(

&nbsp;         # function\_declarations=custom\_functions

&nbsp;         #   )

&nbsp;         ],

&nbsp; )



\# Create the content with user message

contents=\[

&nbsp;   Content(

&nbsp;       role="user",

&nbsp;       parts=\[

&nbsp;           Part(text="Search for highly rated smart fridges with touchscreen, 2 doors, around 25 cu ft, priced below 4000 dollars on Google Shopping. Create a bulleted list of the 3 cheapest options in the format of name, description, price in an easy-to-read layout."),

&nbsp;           # Optional: include a screenshot of the initial state

&nbsp;           #Part.from\_bytes(

&nbsp;               #data=screenshot\_image\_bytes,

&nbsp;               #mime\_type='image/png',

&nbsp;           #),

&nbsp;       ],

&nbsp;   )

]



\# Generate content with the configured settings

response = client.models.generate\_content(

&nbsp;   model='gemini-2.5-computer-use-preview-10-2025',

&nbsp;   contents=contents,

&nbsp;   config=generate\_content\_config,

)



\# Print the response output

print(response)

For an example with custom functions, see Using custom user-defined functions.



2\. Receive the model response

The Computer Use model will respond with one or more FunctionCalls if it determines UI actions are needed to complete the task. Computer Use supports parallel function calling, meaning the model can return multiple actions in a single turn.



Here is an example model response.





{

&nbsp; "content": {

&nbsp;   "parts": \[

&nbsp;     {

&nbsp;       "text": "I will type the search query into the search bar. The search bar is in the center of the page."

&nbsp;     },

&nbsp;     {

&nbsp;       "function\_call": {

&nbsp;         "name": "type\_text\_at",

&nbsp;         "args": {

&nbsp;           "x": 371,

&nbsp;           "y": 470,

&nbsp;           "text": "highly rated smart fridges with touchscreen, 2 doors, around 25 cu ft, priced below 4000 dollars on Google Shopping",

&nbsp;           "press\_enter": true

&nbsp;         }

&nbsp;       }

&nbsp;     }

&nbsp;   ]

&nbsp; }

}

3\. Execute the received actions

Your application code needs to parse the model response, execute the actions, and collect the results.



The example code below extracts function calls from the Computer Use model response, and translates them into actions that can be executed with Playwright. The model outputs normalized coordinates (0-999) regardless of the input image dimensions, so part of the translation step is converting these normalized coordinates back to actual pixel values.



The recommended screen size for use with the Computer Use model is (1440, 900). The model will work with any resolution, though the quality of the results may be impacted.



Note that this example only includes the implementation for the 3 most common UI actions: open\_web\_browser, click\_at, and type\_text\_at. For production use cases, you will need to implement all other UI actions from the Supported actions list unless you explicitly add them as excluded\_predefined\_functions.



Python



from typing import Any, List, Tuple

import time



def denormalize\_x(x: int, screen\_width: int) -> int:

&nbsp;   """Convert normalized x coordinate (0-1000) to actual pixel coordinate."""

&nbsp;   return int(x / 1000 \* screen\_width)



def denormalize\_y(y: int, screen\_height: int) -> int:

&nbsp;   """Convert normalized y coordinate (0-1000) to actual pixel coordinate."""

&nbsp;   return int(y / 1000 \* screen\_height)



def execute\_function\_calls(candidate, page, screen\_width, screen\_height):

&nbsp;   results = \[]

&nbsp;   function\_calls = \[]

&nbsp;   for part in candidate.content.parts:

&nbsp;       if part.function\_call:

&nbsp;           function\_calls.append(part.function\_call)



&nbsp;   for function\_call in function\_calls:

&nbsp;       action\_result = {}

&nbsp;       fname = function\_call.name

&nbsp;       args = function\_call.args

&nbsp;       print(f"  -> Executing: {fname}")



&nbsp;       try:

&nbsp;           if fname == "open\_web\_browser":

&nbsp;               pass # Already open

&nbsp;           elif fname == "click\_at":

&nbsp;               actual\_x = denormalize\_x(args\["x"], screen\_width)

&nbsp;               actual\_y = denormalize\_y(args\["y"], screen\_height)

&nbsp;               page.mouse.click(actual\_x, actual\_y)

&nbsp;           elif fname == "type\_text\_at":

&nbsp;               actual\_x = denormalize\_x(args\["x"], screen\_width)

&nbsp;               actual\_y = denormalize\_y(args\["y"], screen\_height)

&nbsp;               text = args\["text"]

&nbsp;               press\_enter = args.get("press\_enter", False)



&nbsp;               page.mouse.click(actual\_x, actual\_y)

&nbsp;               # Simple clear (Command+A, Backspace for Mac)

&nbsp;               page.keyboard.press("Meta+A")

&nbsp;               page.keyboard.press("Backspace")

&nbsp;               page.keyboard.type(text)

&nbsp;               if press\_enter:

&nbsp;                   page.keyboard.press("Enter")

&nbsp;           else:

&nbsp;               print(f"Warning: Unimplemented or custom function {fname}")



&nbsp;           # Wait for potential navigations/renders

&nbsp;           page.wait\_for\_load\_state(timeout=5000)

&nbsp;           time.sleep(1)



&nbsp;       except Exception as e:

&nbsp;           print(f"Error executing {fname}: {e}")

&nbsp;           action\_result = {"error": str(e)}



&nbsp;       results.append((fname, action\_result))



&nbsp;   return results

4\. Capture the new environment state

After executing the actions, send the result of the function execution back to the model so it can use this information to generate the next action. If multiple actions (parallel calls) were executed, you must send a FunctionResponse for each one in the subsequent user turn.



Python





def get\_function\_responses(page, results):

&nbsp;   screenshot\_bytes = page.screenshot(type="png")

&nbsp;   current\_url = page.url

&nbsp;   function\_responses = \[]

&nbsp;   for name, result in results:

&nbsp;       response\_data = {"url": current\_url}

&nbsp;       response\_data.update(result)

&nbsp;       function\_responses.append(

&nbsp;           types.FunctionResponse(

&nbsp;               name=name,

&nbsp;               response=response\_data,

&nbsp;               parts=\[types.FunctionResponsePart(

&nbsp;                       inline\_data=types.FunctionResponseBlob(

&nbsp;                           mime\_type="image/png",

&nbsp;                           data=screenshot\_bytes))

&nbsp;               ]

&nbsp;           )

&nbsp;       )

&nbsp;   return function\_responses

Build an agent loop

To enable multi-step interactions, combine the four steps from the How to implement Computer Use section into a loop. Remember to manage the conversation history correctly by appending both model responses and your function responses.



To run this code sample you need to:



Install the necessary Playwright dependencies.

Define the helper functions from steps (3) Execute the received actions and (4) Capture the new environment state.



Python





import time

from typing import Any, List, Tuple

from playwright.sync\_api import sync\_playwright



from google import genai

from google.genai import types

from google.genai.types import Content, Part



client = genai.Client()



\# Constants for screen dimensions

SCREEN\_WIDTH = 1440

SCREEN\_HEIGHT = 900



\# Setup Playwright

print("Initializing browser...")

playwright = sync\_playwright().start()

browser = playwright.chromium.launch(headless=False)

context = browser.new\_context(viewport={"width": SCREEN\_WIDTH, "height": SCREEN\_HEIGHT})

page = context.new\_page()



\# Define helper functions. Copy/paste from steps 3 and 4

\# def denormalize\_x(...)

\# def denormalize\_y(...)

\# def execute\_function\_calls(...)

\# def get\_function\_responses(...)



try:

&nbsp;   # Go to initial page

&nbsp;   page.goto("https://ai.google.dev/gemini-api/docs")



&nbsp;   # Configure the model (From Step 1)

&nbsp;   config = types.GenerateContentConfig(

&nbsp;       tools=\[types.Tool(computer\_use=types.ComputerUse(

&nbsp;           environment=types.Environment.ENVIRONMENT\_BROWSER

&nbsp;       ))],

&nbsp;       thinking\_config=types.ThinkingConfig(include\_thoughts=True),

&nbsp;   )



&nbsp;   # Initialize history

&nbsp;   initial\_screenshot = page.screenshot(type="png")

&nbsp;   USER\_PROMPT = "Go to ai.google.dev/gemini-api/docs and search for pricing."

&nbsp;   print(f"Goal: {USER\_PROMPT}")



&nbsp;   contents = \[

&nbsp;       Content(role="user", parts=\[

&nbsp;           Part(text=USER\_PROMPT),

&nbsp;           Part.from\_bytes(data=initial\_screenshot, mime\_type='image/png')

&nbsp;       ])

&nbsp;   ]



&nbsp;   # Agent Loop

&nbsp;   turn\_limit = 5

&nbsp;   for i in range(turn\_limit):

&nbsp;       print(f"\\n--- Turn {i+1} ---")

&nbsp;       print("Thinking...")

&nbsp;       response = client.models.generate\_content(

&nbsp;           model='gemini-2.5-computer-use-preview-10-2025',

&nbsp;           contents=contents,

&nbsp;           config=config,

&nbsp;       )



&nbsp;       candidate = response.candidates\[0]

&nbsp;       contents.append(candidate.content)



&nbsp;       has\_function\_calls = any(part.function\_call for part in candidate.content.parts)

&nbsp;       if not has\_function\_calls:

&nbsp;           text\_response = " ".join(\[part.text for part in candidate.content.parts if part.text])

&nbsp;           print("Agent finished:", text\_response)

&nbsp;           break



&nbsp;       print("Executing actions...")

&nbsp;       results = execute\_function\_calls(candidate, page, SCREEN\_WIDTH, SCREEN\_HEIGHT)



&nbsp;       print("Capturing state...")

&nbsp;       function\_responses = get\_function\_responses(page, results)



&nbsp;       contents.append(

&nbsp;           Content(role="user", parts=\[Part(function\_response=fr) for fr in function\_responses])

&nbsp;       )



finally:

&nbsp;   # Cleanup

&nbsp;   print("\\nClosing browser...")

&nbsp;   browser.close()

&nbsp;   playwright.stop()

Using custom user-defined functions

You can optionally include custom user-defined functions in your request to extend the functionality of the model. The example below adapts the Computer Use model and tool for mobile use cases by including custom user-defined actions like open\_app, long\_press\_at, and go\_home, while excluding browser-specific actions. The model can intelligently call these custom functions alongside standard UI actions to complete tasks in non-browser environments.



Python



from typing import Optional, Dict, Any



from google import genai

from google.genai import types

from google.genai.types import Content, Part



client = genai.Client()



SYSTEM\_PROMPT = """You are operating an Android phone. Today's date is October 15, 2023, so ignore any other date provided.

\* To provide an answer to the user, \*do not use any tools\* and output your answer on a separate line. IMPORTANT: Do not add any formatting or additional punctuation/text, just output the answer by itself after two empty lines.

\* Make sure you scroll down to see everything before deciding something isn't available.

\* You can open an app from anywhere. The icon doesn't have to currently be on screen.

\* Unless explicitly told otherwise, make sure to save any changes you make.

\* If text is cut off or incomplete, scroll or click into the element to get the full text before providing an answer.

\* IMPORTANT: Complete the given task EXACTLY as stated. DO NOT make any assumptions that completing a similar task is correct.  If you can't find what you're looking for, SCROLL to find it.

\* If you want to edit some text, ONLY USE THE `type` tool. Do not use the onscreen keyboard.

\* Quick settings shouldn't be used to change settings. Use the Settings app instead.

\* The given task may already be completed. If so, there is no need to do anything.

"""



def open\_app(app\_name: str, intent: Optional\[str] = None) -> Dict\[str, Any]:

&nbsp;   """Opens an app by name.



&nbsp;   Args:

&nbsp;       app\_name: Name of the app to open (any string).

&nbsp;       intent: Optional deep-link or action to pass when launching, if the app supports it.



&nbsp;   Returns:

&nbsp;       JSON payload acknowledging the request (app name and optional intent).

&nbsp;   """

&nbsp;   return {"status": "requested\_open", "app\_name": app\_name, "intent": intent}



def long\_press\_at(x: int, y: int) -> Dict\[str, int]:

&nbsp;   """Long-press at a specific screen coordinate.



&nbsp;   Args:

&nbsp;       x: X coordinate (absolute), scaled to the device screen width (pixels).

&nbsp;       y: Y coordinate (absolute), scaled to the device screen height (pixels).



&nbsp;   Returns:

&nbsp;       Object with the coordinates pressed and the duration used.

&nbsp;   """

&nbsp;   return {"x": x, "y": y}



def go\_home() -> Dict\[str, str]:

&nbsp;   """Navigates to the device home screen.



&nbsp;   Returns:

&nbsp;       A small acknowledgment payload.

&nbsp;   """

&nbsp;   return {"status": "home\_requested"}



\#  Build function declarations

CUSTOM\_FUNCTION\_DECLARATIONS = \[

&nbsp;   types.FunctionDeclaration.from\_callable(client=client, callable=open\_app),

&nbsp;   types.FunctionDeclaration.from\_callable(client=client, callable=long\_press\_at),

&nbsp;   types.FunctionDeclaration.from\_callable(client=client, callable=go\_home),

]



\#Exclude browser functions

EXCLUDED\_PREDEFINED\_FUNCTIONS = \[

&nbsp;   "open\_web\_browser",

&nbsp;   "search",

&nbsp;   "navigate",

&nbsp;   "hover\_at",

&nbsp;   "scroll\_document",

&nbsp;   "go\_forward",

&nbsp;   "key\_combination",

&nbsp;   "drag\_and\_drop",

]



\#Utility function to construct a GenerateContentConfig

def make\_generate\_content\_config() -> genai.types.GenerateContentConfig:

&nbsp;   """Return a fixed GenerateContentConfig with Computer Use + custom functions."""

&nbsp;   return genai.types.GenerateContentConfig(

&nbsp;       system\_instruction=SYSTEM\_PROMPT,

&nbsp;       tools=\[

&nbsp;           types.Tool(

&nbsp;               computer\_use=types.ComputerUse(

&nbsp;                   environment=types.Environment.ENVIRONMENT\_BROWSER,

&nbsp;                   excluded\_predefined\_functions=EXCLUDED\_PREDEFINED\_FUNCTIONS,

&nbsp;               )

&nbsp;           ),

&nbsp;           types.Tool(function\_declarations=CUSTOM\_FUNCTION\_DECLARATIONS),

&nbsp;       ],

&nbsp;   )



\# Create the content with user message

contents: list\[Content] = \[

&nbsp;   Content(

&nbsp;       role="user",

&nbsp;       parts=\[

&nbsp;           # text instruction

&nbsp;           Part(text="Open Chrome, then long-press at 200,400."),

&nbsp;           # optional screenshot attachment

&nbsp;           Part.from\_bytes(

&nbsp;               data=screenshot\_image\_bytes,

&nbsp;               mime\_type="image/png",

&nbsp;           ),

&nbsp;       ],

&nbsp;   )

]



\# Build your fixed config (from helper)

config = make\_generate\_content\_config()



\# Generate content with the configured settings

response = client.models.generate\_content(

&nbsp;       model='gemini-2.5-computer-use-preview-10-2025',

&nbsp;       contents=contents,

&nbsp;       config=config,

&nbsp;   )



print(response)

Supported UI actions

The Computer Use model can request the following UI actions via a FunctionCall. Your client-side code must implement the execution logic for these actions. See the reference implementation for examples.



Command Name	Description	Arguments (in Function Call)	Example Function Call

open\_web\_browser	Opens the web browser.	None	{"name": "open\_web\_browser", "args": {}}

wait\_5\_seconds	Pauses execution for 5 seconds to allow dynamic content to load or animations to complete.	None	{"name": "wait\_5\_seconds", "args": {}}

go\_back	Navigates to the previous page in the browser's history.	None	{"name": "go\_back", "args": {}}

go\_forward	Navigates to the next page in the browser's history.	None	{"name": "go\_forward", "args": {}}

search	Navigates to the default search engine's homepage (e.g., Google). Useful for starting a new search task.	None	{"name": "search", "args": {}}

navigate	Navigates the browser directly to the specified URL.	url: str	{"name": "navigate", "args": {"url": "https://www.wikipedia.org"}}

click\_at	Clicks at a specific coordinate on the webpage. The x and y values are based on a 1000x1000 grid and are scaled to the screen dimensions.	y: int (0-999), x: int (0-999)	{"name": "click\_at", "args": {"y": 300, "x": 500}}

hover\_at	Hovers the mouse at a specific coordinate on the webpage. Useful for revealing sub-menus. x and y are based on a 1000x1000 grid.	y: int (0-999) x: int (0-999)	{"name": "hover\_at", "args": {"y": 150, "x": 250}}

type\_text\_at	Types text at a specific coordinate, defaults to clearing the field first and pressing ENTER after typing, but these can be disabled. x and y are based on a 1000x1000 grid.	y: int (0-999), x: int (0-999), text: str, press\_enter: bool (Optional, default True), clear\_before\_typing: bool (Optional, default True)	{"name": "type\_text\_at", "args": {"y": 250, "x": 400, "text": "search query", "press\_enter": false}}

key\_combination	Press keyboard keys or combinations, such as "Control+C" or "Enter". Useful for triggering actions (like submitting a form with "Enter") or clipboard operations.	keys: str (e.g. 'enter', 'control+c').	{"name": "key\_combination", "args": {"keys": "Control+A"}}

scroll\_document	Scrolls the entire webpage "up", "down", "left", or "right".	direction: str ("up", "down", "left", or "right")	{"name": "scroll\_document", "args": {"direction": "down"}}

scroll\_at	Scrolls a specific element or area at coordinate (x, y) in the specified direction by a certain magnitude. Coordinates and magnitude (default 800) are based on a 1000x1000 grid.	y: int (0-999), x: int (0-999), direction: str ("up", "down", "left", "right"), magnitude: int (0-999, Optional, default 800)	{"name": "scroll\_at", "args": {"y": 500, "x": 500, "direction": "down", "magnitude": 400}}

drag\_and\_drop	Drags an element from a starting coordinate (x, y) and drops it at a destination coordinate (destination\_x, destination\_y). All coordinates are based on a 1000x1000 grid.	y: int (0-999), x: int (0-999), destination\_y: int (0-999), destination\_x: int (0-999)	{"name": "drag\_and\_drop", "args": {"y": 100, "x": 100, "destination\_y": 500, "destination\_x": 500}}

Safety and security

Acknowledge safety decision

Depending on the action, the model response might also include a safety\_decision from an internal safety system that checks the model's proposed action.





{

&nbsp; "content": {

&nbsp;   "parts": \[

&nbsp;     {

&nbsp;       "text": "I have evaluated step 2. It seems Google detected unusual traffic and is asking me to verify I'm not a robot. I need to click the 'I'm not a robot' checkbox located near the top left (y=98, x=95).",

&nbsp;     },

&nbsp;     {

&nbsp;       "function\_call": {

&nbsp;         "name": "click\_at",

&nbsp;         "args": {

&nbsp;           "x": 60,

&nbsp;           "y": 100,

&nbsp;           "safety\_decision": {

&nbsp;             "explanation": "I have encountered a CAPTCHA challenge that requires interaction. I need you to complete the challenge by clicking the 'I'm not a robot' checkbox and any subsequent verification steps.",

&nbsp;             "decision": "require\_confirmation"

&nbsp;           }

&nbsp;         }

&nbsp;       }

&nbsp;     }

&nbsp;   ]

&nbsp; }

}

If the safety\_decision is require\_confirmation, you must ask the end user to confirm before proceeding with executing the action. Per the terms of service, you are not allowed to bypass requests for human confirmation.



This code sample prompts the end-user for confirmation before executing the action. If the user does not confirm the action, the loop terminates. If the user confirms the action, the action is executed and the safety\_acknowledgement field is marked as True.



Python



import termcolor



def get\_safety\_confirmation(safety\_decision):

&nbsp;   """Prompt user for confirmation when safety check is triggered."""

&nbsp;   termcolor.cprint("Safety service requires explicit confirmation!", color="red")

&nbsp;   print(safety\_decision\["explanation"])



&nbsp;   decision = ""

&nbsp;   while decision.lower() not in ("y", "n", "ye", "yes", "no"):

&nbsp;       decision = input("Do you wish to proceed? \[Y]es/\[N]o\\n")



&nbsp;   if decision.lower() in ("n", "no"):

&nbsp;       return "TERMINATE"

&nbsp;   return "CONTINUE"



def execute\_function\_calls(candidate, page, screen\_width, screen\_height):



&nbsp;   # ... Extract function calls from response ...



&nbsp;   for function\_call in function\_calls:

&nbsp;       extra\_fr\_fields = {}



&nbsp;       # Check for safety decision

&nbsp;       if 'safety\_decision' in function\_call.args:

&nbsp;           decision = get\_safety\_confirmation(function\_call.args\['safety\_decision'])

&nbsp;           if decision == "TERMINATE":

&nbsp;               print("Terminating agent loop")

&nbsp;               break

&nbsp;           extra\_fr\_fields\["safety\_acknowledgement"] = "true" # Safety acknowledgement



&nbsp;       # ... Execute function call and append to results ...

If the user confirms, you must include the safety acknowledgement in your FunctionResponse.



Python



function\_response\_parts.append(

&nbsp;   FunctionResponse(

&nbsp;       name=name,

&nbsp;       response={"url": current\_url,

&nbsp;                 \*\*extra\_fr\_fields},  # Include safety acknowledgement

&nbsp;       parts=\[

&nbsp;           types.FunctionResponsePart(

&nbsp;               inline\_data=types.FunctionResponseBlob(

&nbsp;                   mime\_type="image/png", data=screenshot

&nbsp;               )

&nbsp;            )

&nbsp;          ]

&nbsp;        )

&nbsp;      )

Safety best practices

Computer Use API is a novel API and presents new risks that developers should be mindful of:



Untrusted content \& scams: As the model tries to achieve the user's goal, it may rely on untrustworthy sources of information and instructions from the screen. For example, if the user's goal is to purchase a Pixel phone and the model encounters a "Free-Pixel if you complete a survey" scam, there is some chance that the model will complete the survey.

Occasional unintended actions: The model can misinterpret a user's goal or webpage content, causing it to take incorrect actions like clicking the wrong button or filling the wrong form. This can lead to failed tasks or data exfiltration.

Policy violations: The API's capabilities could be directed, either intentionally or unintentionally, toward activities that violate Google's policies (Gen AI Prohibited Use Policy and the Gemini API Additional Terms of Service. This includes actions that could interfere with a system's integrity, compromise security, bypass security measures, control medical devices, etc.

To address these risks, you can implement the following safety measures and best practices:



Human-in-the-Loop (HITL):



Implement user confirmation: When the safety response indicates require\_confirmation, you must implement user confirmation before execution. See Acknowledge safety decision for sample code.

Provide custom safety instructions: In addition to the built-in user confirmation checks, developers may optionally add a custom system instruction that enforces their own safety policies, either to block certain model actions or require user confirmation before the model takes certain high-stakes irreversible actions. Here is an example of a custom safety system instruction you may include when interacting with the model.



Example safety instructions

Secure execution environment: Run your agent in a secure, sandboxed environment to limit its potential impact (e.g., A sandboxed virtual machine (VM), a container (e.g., Docker), or a dedicated browser profile with limited permissions).



Input sanitization: Sanitize all user-generated text in prompts to mitigate the risk of unintended instructions or prompt injection. This is a helpful layer of security, but not a replacement for a secure execution environment.



Content guardrails: Use guardrails and content safety APIs to evaluate user inputs, tool input and output, an agent's response for appropriateness, prompt injection, and jailbreak detection.



Allowlists and blocklists: Implement filtering mechanisms to control where the model can navigate and what it can do. A blocklist of prohibited websites is a good starting point, while a more restrictive allowlist is even more secure.



Observability and logging: Maintain detailed logs for debugging, auditing, and incident response. Your client should log prompts, screenshots, model-suggested actions (function\_call), safety responses, and all actions ultimately executed by the client.



Environment management: Ensure the GUI environment is consistent. Unexpected pop-ups, notifications, or changes in layout can confuse the model. Start from a known, clean state for each new task if possible.



Model versions

Property	Description

Model code

Gemini API



gemini-2.5-computer-use-preview-10-2025



Supported data types

Input



Image, text



Output



Text



Token limits\[\*]

Input token limit



128,000



Output token limit



64,000



Versions	

Read the model version patterns for more details.

Preview: gemini-2.5-computer-use-preview-10-2025

Latest update	October 2025

