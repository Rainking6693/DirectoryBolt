// üîê SESSION MANAGEMENT MIDDLEWARE - AUTH-002
// Comprehensive session handling for staff dashboard and user authentication
// Implements secure session storage, validation, and automatic renewal

import type { NextApiRequest, NextApiResponse } from 'next';
import { serialize, parse } from 'cookie';
import crypto from 'crypto';

// Session Configuration
const SESSION_CONFIG = {
  // Session settings
  sessionName: 'directorybolt_session',
  staffSessionName: 'staff_session',
  maxAge: 24 * 60 * 60 * 1000, // 24 hours
  staffMaxAge: 8 * 60 * 60 * 1000, // 8 hours for staff
  
  // Security settings
  secure: process.env.NODE_ENV === 'production',
  httpOnly: true,
  sameSite: 'strict' as const,
  
  // Session storage (in production, use Redis or database)
  storage: new Map<string, SessionData>(),
  
  // Cleanup interval
  cleanupInterval: 60 * 60 * 1000, // 1 hour
  
  // Session renewal threshold
  renewalThreshold: 30 * 60 * 1000, // Renew if less than 30 minutes remaining
};\n\n// Session data interface\ninterface SessionData {\n  id: string;\n  userId: string;\n  userType: 'customer' | 'staff';\n  email: string;\n  role?: string;\n  permissions?: string[];\n  createdAt: number;\n  lastAccessed: number;\n  expiresAt: number;\n  ipAddress: string;\n  userAgent: string;\n  isActive: boolean;\n}\n\n// Session manager class\nclass SessionManager {\n  private static instance: SessionManager;\n  private cleanupTimer: NodeJS.Timeout | null = null;\n  \n  constructor() {\n    this.startCleanupTimer();\n  }\n  \n  static getInstance(): SessionManager {\n    if (!SessionManager.instance) {\n      SessionManager.instance = new SessionManager();\n    }\n    return SessionManager.instance;\n  }\n  \n  // Create a new session\n  createSession(\n    userId: string,\n    userType: 'customer' | 'staff',\n    email: string,\n    ipAddress: string,\n    userAgent: string,\n    role?: string,\n    permissions?: string[]\n  ): SessionData {\n    const sessionId = this.generateSessionId();\n    const now = Date.now();\n    const maxAge = userType === 'staff' ? SESSION_CONFIG.staffMaxAge : SESSION_CONFIG.maxAge;\n    \n    const sessionData: SessionData = {\n      id: sessionId,\n      userId,\n      userType,\n      email,\n      role,\n      permissions,\n      createdAt: now,\n      lastAccessed: now,\n      expiresAt: now + maxAge,\n      ipAddress,\n      userAgent,\n      isActive: true\n    };\n    \n    SESSION_CONFIG.storage.set(sessionId, sessionData);\n    \n    console.log('‚úÖ Session created', {\n      sessionId,\n      userId,\n      userType,\n      email,\n      expiresAt: new Date(sessionData.expiresAt).toISOString()\n    });\n    \n    return sessionData;\n  }\n  \n  // Validate and retrieve session\n  validateSession(sessionId: string, ipAddress: string, userAgent: string): SessionData | null {\n    const session = SESSION_CONFIG.storage.get(sessionId);\n    \n    if (!session) {\n      return null;\n    }\n    \n    // Check if session is expired\n    if (Date.now() > session.expiresAt) {\n      this.destroySession(sessionId);\n      return null;\n    }\n    \n    // Check if session is active\n    if (!session.isActive) {\n      return null;\n    }\n    \n    // Security check: IP address validation (optional, can be disabled for mobile users)\n    if (process.env.STRICT_IP_VALIDATION === 'true' && session.ipAddress !== ipAddress) {\n      console.warn('‚ö†Ô∏è Session IP mismatch', {\n        sessionId,\n        originalIP: session.ipAddress,\n        currentIP: ipAddress\n      });\n      // Optionally destroy session or just log the warning\n      // this.destroySession(sessionId);\n      // return null;\n    }\n    \n    // Update last accessed time\n    session.lastAccessed = Date.now();\n    SESSION_CONFIG.storage.set(sessionId, session);\n    \n    return session;\n  }\n  \n  // Renew session if close to expiry\n  renewSession(sessionId: string): SessionData | null {\n    const session = SESSION_CONFIG.storage.get(sessionId);\n    \n    if (!session) {\n      return null;\n    }\n    \n    const now = Date.now();\n    const timeUntilExpiry = session.expiresAt - now;\n    \n    // Renew if within renewal threshold\n    if (timeUntilExpiry < SESSION_CONFIG.renewalThreshold) {\n      const maxAge = session.userType === 'staff' ? SESSION_CONFIG.staffMaxAge : SESSION_CONFIG.maxAge;\n      session.expiresAt = now + maxAge;\n      session.lastAccessed = now;\n      \n      SESSION_CONFIG.storage.set(sessionId, session);\n      \n      console.log('üîÑ Session renewed', {\n        sessionId,\n        userId: session.userId,\n        newExpiresAt: new Date(session.expiresAt).toISOString()\n      });\n    }\n    \n    return session;\n  }\n  \n  // Destroy session\n  destroySession(sessionId: string): boolean {\n    const session = SESSION_CONFIG.storage.get(sessionId);\n    const deleted = SESSION_CONFIG.storage.delete(sessionId);\n    \n    if (deleted && session) {\n      console.log('üóëÔ∏è Session destroyed', {\n        sessionId,\n        userId: session.userId,\n        userType: session.userType\n      });\n    }\n    \n    return deleted;\n  }\n  \n  // Destroy all sessions for a user\n  destroyUserSessions(userId: string): number {\n    let destroyedCount = 0;\n    \n    for (const [sessionId, session] of SESSION_CONFIG.storage.entries()) {\n      if (session.userId === userId) {\n        SESSION_CONFIG.storage.delete(sessionId);\n        destroyedCount++;\n      }\n    }\n    \n    console.log('üóëÔ∏è User sessions destroyed', {\n      userId,\n      destroyedCount\n    });\n    \n    return destroyedCount;\n  }\n  \n  // Get active sessions for a user\n  getUserSessions(userId: string): SessionData[] {\n    const userSessions: SessionData[] = [];\n    const now = Date.now();\n    \n    for (const session of SESSION_CONFIG.storage.values()) {\n      if (session.userId === userId && session.isActive && now < session.expiresAt) {\n        userSessions.push(session);\n      }\n    }\n    \n    return userSessions;\n  }\n  \n  // Generate secure session ID\n  private generateSessionId(): string {\n    return crypto.randomBytes(32).toString('hex');\n  }\n  \n  // Cleanup expired sessions\n  private cleanupExpiredSessions(): void {\n    const now = Date.now();\n    let cleanedCount = 0;\n    \n    for (const [sessionId, session] of SESSION_CONFIG.storage.entries()) {\n      if (now > session.expiresAt) {\n        SESSION_CONFIG.storage.delete(sessionId);\n        cleanedCount++;\n      }\n    }\n    \n    if (cleanedCount > 0) {\n      console.log('üßπ Cleaned up expired sessions', {\n        cleanedCount,\n        remainingSessions: SESSION_CONFIG.storage.size\n      });\n    }\n  }\n  \n  // Start automatic cleanup timer\n  private startCleanupTimer(): void {\n    this.cleanupTimer = setInterval(() => {\n      this.cleanupExpiredSessions();\n    }, SESSION_CONFIG.cleanupInterval);\n  }\n  \n  // Stop cleanup timer\n  stopCleanupTimer(): void {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n  }\n}\n\n// Middleware function for session validation\nexport function withSessionValidation(\n  userType: 'customer' | 'staff' | 'any' = 'any',\n  required: boolean = true\n) {\n  return function middleware(\n    handler: (req: NextApiRequest & { session?: SessionData }, res: NextApiResponse) => Promise<void> | void\n  ) {\n    return async function wrappedHandler(\n      req: NextApiRequest & { session?: SessionData },\n      res: NextApiResponse\n    ) {\n      const sessionManager = SessionManager.getInstance();\n      const clientIP = getClientIP(req);\n      const userAgent = req.headers['user-agent'] || '';\n      \n      // Get session ID from cookies\n      const cookies = parse(req.headers.cookie || '');\n      const sessionId = userType === 'staff' \n        ? cookies[SESSION_CONFIG.staffSessionName]\n        : cookies[SESSION_CONFIG.sessionName];\n      \n      if (sessionId) {\n        // Validate session\n        const session = sessionManager.validateSession(sessionId, clientIP, userAgent);\n        \n        if (session) {\n          // Check user type if specified\n          if (userType !== 'any' && session.userType !== userType) {\n            return res.status(403).json({\n              error: 'Access Denied',\n              message: 'Invalid user type for this resource',\n              code: 'INVALID_USER_TYPE'\n            });\n          }\n          \n          // Renew session if needed\n          sessionManager.renewSession(sessionId);\n          \n          // Attach session to request\n          req.session = session;\n          \n          // Set renewed session cookie\n          const cookieName = session.userType === 'staff' \n            ? SESSION_CONFIG.staffSessionName \n            : SESSION_CONFIG.sessionName;\n          \n          const cookie = serialize(cookieName, sessionId, {\n            maxAge: session.userType === 'staff' ? SESSION_CONFIG.staffMaxAge : SESSION_CONFIG.maxAge,\n            httpOnly: SESSION_CONFIG.httpOnly,\n            secure: SESSION_CONFIG.secure,\n            sameSite: SESSION_CONFIG.sameSite,\n            path: '/'\n          });\n          \n          res.setHeader('Set-Cookie', cookie);\n        } else if (required) {\n          // Invalid or expired session\n          return res.status(401).json({\n            error: 'Authentication Required',\n            message: 'Your session has expired. Please log in again.',\n            code: 'SESSION_EXPIRED'\n          });\n        }\n      } else if (required) {\n        // No session found\n        return res.status(401).json({\n          error: 'Authentication Required',\n          message: 'Please log in to access this resource.',\n          code: 'NO_SESSION'\n        });\n      }\n      \n      // Continue to the actual handler\n      return handler(req, res);\n    };\n  };\n}\n\n// Helper function to create session cookie\nexport function createSessionCookie(\n  sessionData: SessionData\n): string {\n  const cookieName = sessionData.userType === 'staff' \n    ? SESSION_CONFIG.staffSessionName \n    : SESSION_CONFIG.sessionName;\n  \n  return serialize(cookieName, sessionData.id, {\n    maxAge: sessionData.userType === 'staff' ? SESSION_CONFIG.staffMaxAge : SESSION_CONFIG.maxAge,\n    httpOnly: SESSION_CONFIG.httpOnly,\n    secure: SESSION_CONFIG.secure,\n    sameSite: SESSION_CONFIG.sameSite,\n    path: '/'\n  });\n}\n\n// Helper function to destroy session cookie\nexport function destroySessionCookie(\n  userType: 'customer' | 'staff'\n): string {\n  const cookieName = userType === 'staff' \n    ? SESSION_CONFIG.staffSessionName \n    : SESSION_CONFIG.sessionName;\n  \n  return serialize(cookieName, '', {\n    maxAge: 0,\n    httpOnly: SESSION_CONFIG.httpOnly,\n    secure: SESSION_CONFIG.secure,\n    sameSite: SESSION_CONFIG.sameSite,\n    path: '/'\n  });\n}\n\n// Get client IP address\nfunction getClientIP(req: NextApiRequest): string {\n  const forwarded = req.headers['x-forwarded-for'];\n  const realIP = req.headers['x-real-ip'];\n  const cfConnectingIP = req.headers['cf-connecting-ip'];\n  \n  if (typeof forwarded === 'string') {\n    return forwarded.split(',')[0].trim();\n  }\n  \n  if (typeof realIP === 'string') {\n    return realIP;\n  }\n  \n  if (typeof cfConnectingIP === 'string') {\n    return cfConnectingIP;\n  }\n  \n  return req.socket.remoteAddress || 'unknown';\n}\n\n// Export session manager for direct use\nexport { SessionManager, SESSION_CONFIG };\nexport type { SessionData };"