// ðŸ”” ENHANCED STRIPE WEBHOOK HANDLER\n// Complete webhook processing for payment events and customer management\n\nimport { NextApiRequest, NextApiResponse } from 'next'\nimport Stripe from 'stripe'\nimport { buffer } from 'micro'\nimport { logger } from '../../../lib/utils/logger'\n\n// Initialize Stripe\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {\n  apiVersion: '2023-10-16',\n})\n\nconst webhookSecret = process.env.STRIPE_WEBHOOK_SECRET!\n\n// Disable body parsing for webhook\nexport const config = {\n  api: {\n    bodyParser: false,\n  },\n}\n\ninterface CustomerData {\n  stripeCustomerId: string\n  email: string\n  name?: string\n  phone?: string\n  plan: string\n  planName: string\n  amount: number\n  paymentStatus: string\n  subscriptionStatus?: string\n  metadata: Record<string, any>\n  createdAt: string\n  updatedAt: string\n}\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' })\n  }\n\n  try {\n    const buf = await buffer(req)\n    const signature = req.headers['stripe-signature'] as string\n\n    if (!signature) {\n      logger.error('Missing Stripe signature')\n      return res.status(400).json({ error: 'Missing signature' })\n    }\n\n    // Verify webhook signature\n    let event: Stripe.Event\n    try {\n      event = stripe.webhooks.constructEvent(buf, signature, webhookSecret)\n    } catch (error) {\n      logger.error('Webhook signature verification failed', {}, error as Error)\n      return res.status(400).json({ error: 'Invalid signature' })\n    }\n\n    logger.info('Stripe webhook received', {\n      metadata: {\n        eventType: event.type,\n        eventId: event.id\n      }\n    })\n\n    // Handle different event types\n    switch (event.type) {\n      case 'checkout.session.completed':\n        await handleCheckoutCompleted(event.data.object as Stripe.Checkout.Session)\n        break\n        \n      case 'payment_intent.succeeded':\n        await handlePaymentSucceeded(event.data.object as Stripe.PaymentIntent)\n        break\n        \n      case 'payment_intent.payment_failed':\n        await handlePaymentFailed(event.data.object as Stripe.PaymentIntent)\n        break\n        \n      case 'customer.created':\n        await handleCustomerCreated(event.data.object as Stripe.Customer)\n        break\n        \n      case 'customer.updated':\n        await handleCustomerUpdated(event.data.object as Stripe.Customer)\n        break\n        \n      case 'invoice.payment_succeeded':\n        await handleInvoicePaymentSucceeded(event.data.object as Stripe.Invoice)\n        break\n        \n      case 'invoice.payment_failed':\n        await handleInvoicePaymentFailed(event.data.object as Stripe.Invoice)\n        break\n        \n      default:\n        logger.info('Unhandled webhook event type', {\n          metadata: { eventType: event.type }\n        })\n    }\n\n    return res.status(200).json({ received: true })\n\n  } catch (error) {\n    logger.error('Webhook processing failed', {}, error as Error)\n    return res.status(500).json({ error: 'Webhook processing failed' })\n  }\n}\n\n/**\n * Handle successful checkout completion\n */\nasync function handleCheckoutCompleted(session: Stripe.Checkout.Session) {\n  try {\n    logger.info('Processing checkout completion', {\n      metadata: {\n        sessionId: session.id,\n        customerId: session.customer,\n        amount: session.amount_total,\n        plan: session.metadata?.plan\n      }\n    })\n\n    // Extract customer and payment information\n    const customerData: Partial<CustomerData> = {\n      stripeCustomerId: session.customer as string,\n      email: session.customer_details?.email || '',\n      name: session.customer_details?.name || '',\n      phone: session.customer_details?.phone || '',\n      plan: session.metadata?.plan || 'unknown',\n      planName: session.metadata?.planName || 'Unknown Plan',\n      amount: session.amount_total || 0,\n      paymentStatus: 'completed',\n      metadata: session.metadata || {},\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    }\n\n    // Store customer data (implement your storage logic)\n    await storeCustomerData(customerData)\n    \n    // Trigger analysis process\n    await triggerAnalysisProcess(customerData)\n    \n    // Send confirmation email\n    await sendConfirmationEmail(customerData)\n    \n    logger.info('Checkout completion processed successfully', {\n      metadata: {\n        customerId: customerData.stripeCustomerId,\n        plan: customerData.plan\n      }\n    })\n\n  } catch (error) {\n    logger.error('Failed to process checkout completion', {}, error as Error)\n    throw error\n  }\n}\n\n/**\n * Handle successful payment\n */\nasync function handlePaymentSucceeded(paymentIntent: Stripe.PaymentIntent) {\n  try {\n    logger.info('Processing payment success', {\n      metadata: {\n        paymentIntentId: paymentIntent.id,\n        customerId: paymentIntent.customer,\n        amount: paymentIntent.amount\n      }\n    })\n\n    // Update payment status in database\n    await updatePaymentStatus(paymentIntent.id, 'succeeded')\n    \n    // Send payment confirmation\n    await sendPaymentConfirmation(paymentIntent)\n\n  } catch (error) {\n    logger.error('Failed to process payment success', {}, error as Error)\n    throw error\n  }\n}\n\n/**\n * Handle failed payment\n */\nasync function handlePaymentFailed(paymentIntent: Stripe.PaymentIntent) {\n  try {\n    logger.info('Processing payment failure', {\n      metadata: {\n        paymentIntentId: paymentIntent.id,\n        customerId: paymentIntent.customer,\n        amount: paymentIntent.amount,\n        failureReason: paymentIntent.last_payment_error?.message\n      }\n    })\n\n    // Update payment status in database\n    await updatePaymentStatus(paymentIntent.id, 'failed')\n    \n    // Send payment failure notification\n    await sendPaymentFailureNotification(paymentIntent)\n\n  } catch (error) {\n    logger.error('Failed to process payment failure', {}, error as Error)\n    throw error\n  }\n}\n\n/**\n * Handle customer creation\n */\nasync function handleCustomerCreated(customer: Stripe.Customer) {\n  try {\n    logger.info('Processing customer creation', {\n      metadata: {\n        customerId: customer.id,\n        email: customer.email\n      }\n    })\n\n    // Store customer information\n    await storeCustomerProfile(customer)\n\n  } catch (error) {\n    logger.error('Failed to process customer creation', {}, error as Error)\n    throw error\n  }\n}\n\n/**\n * Handle customer updates\n */\nasync function handleCustomerUpdated(customer: Stripe.Customer) {\n  try {\n    logger.info('Processing customer update', {\n      metadata: {\n        customerId: customer.id,\n        email: customer.email\n      }\n    })\n\n    // Update customer information\n    await updateCustomerProfile(customer)\n\n  } catch (error) {\n    logger.error('Failed to process customer update', {}, error as Error)\n    throw error\n  }\n}\n\n/**\n * Handle successful invoice payment\n */\nasync function handleInvoicePaymentSucceeded(invoice: Stripe.Invoice) {\n  try {\n    logger.info('Processing invoice payment success', {\n      metadata: {\n        invoiceId: invoice.id,\n        customerId: invoice.customer,\n        amount: invoice.amount_paid\n      }\n    })\n\n    // Process invoice payment\n    await processInvoicePayment(invoice)\n\n  } catch (error) {\n    logger.error('Failed to process invoice payment success', {}, error as Error)\n    throw error\n  }\n}\n\n/**\n * Handle failed invoice payment\n */\nasync function handleInvoicePaymentFailed(invoice: Stripe.Invoice) {\n  try {\n    logger.info('Processing invoice payment failure', {\n      metadata: {\n        invoiceId: invoice.id,\n        customerId: invoice.customer,\n        amount: invoice.amount_due\n      }\n    })\n\n    // Handle invoice payment failure\n    await handleInvoiceFailure(invoice)\n\n  } catch (error) {\n    logger.error('Failed to process invoice payment failure', {}, error as Error)\n    throw error\n  }\n}\n\n// Helper functions (implement based on your storage and notification systems)\n\n/**\n * Store customer data in your database\n */\nasync function storeCustomerData(customerData: Partial<CustomerData>) {\n  try {\n    // Implement your database storage logic here\n    // This could be Airtable, PostgreSQL, MongoDB, etc.\n    \n    logger.info('Customer data stored successfully', {\n      metadata: {\n        customerId: customerData.stripeCustomerId,\n        plan: customerData.plan\n      }\n    })\n  } catch (error) {\n    logger.error('Failed to store customer data', {}, error as Error)\n    throw error\n  }\n}\n\n/**\n * Trigger the AI analysis process for the customer\n */\nasync function triggerAnalysisProcess(customerData: Partial<CustomerData>) {\n  try {\n    // Implement your analysis triggering logic here\n    // This could queue a job, call an API, etc.\n    \n    logger.info('Analysis process triggered', {\n      metadata: {\n        customerId: customerData.stripeCustomerId,\n        plan: customerData.plan\n      }\n    })\n  } catch (error) {\n    logger.error('Failed to trigger analysis process', {}, error as Error)\n    throw error\n  }\n}\n\n/**\n * Send confirmation email to customer\n */\nasync function sendConfirmationEmail(customerData: Partial<CustomerData>) {\n  try {\n    // Implement your email sending logic here\n    // This could use SendGrid, AWS SES, etc.\n    \n    logger.info('Confirmation email sent', {\n      metadata: {\n        email: customerData.email,\n        plan: customerData.plan\n      }\n    })\n  } catch (error) {\n    logger.error('Failed to send confirmation email', {}, error as Error)\n    // Don't throw here - email failure shouldn't break the webhook\n  }\n}\n\n/**\n * Update payment status in database\n */\nasync function updatePaymentStatus(paymentIntentId: string, status: string) {\n  try {\n    // Implement your database update logic here\n    \n    logger.info('Payment status updated', {\n      metadata: {\n        paymentIntentId,\n        status\n      }\n    })\n  } catch (error) {\n    logger.error('Failed to update payment status', {}, error as Error)\n    throw error\n  }\n}\n\n/**\n * Send payment confirmation\n */\nasync function sendPaymentConfirmation(paymentIntent: Stripe.PaymentIntent) {\n  try {\n    // Implement your payment confirmation logic here\n    \n    logger.info('Payment confirmation sent', {\n      metadata: {\n        paymentIntentId: paymentIntent.id\n      }\n    })\n  } catch (error) {\n    logger.error('Failed to send payment confirmation', {}, error as Error)\n    // Don't throw here - email failure shouldn't break the webhook\n  }\n}\n\n/**\n * Send payment failure notification\n */\nasync function sendPaymentFailureNotification(paymentIntent: Stripe.PaymentIntent) {\n  try {\n    // Implement your payment failure notification logic here\n    \n    logger.info('Payment failure notification sent', {\n      metadata: {\n        paymentIntentId: paymentIntent.id\n      }\n    })\n  } catch (error) {\n    logger.error('Failed to send payment failure notification', {}, error as Error)\n    // Don't throw here - email failure shouldn't break the webhook\n  }\n}\n\n/**\n * Store customer profile\n */\nasync function storeCustomerProfile(customer: Stripe.Customer) {\n  try {\n    // Implement your customer profile storage logic here\n    \n    logger.info('Customer profile stored', {\n      metadata: {\n        customerId: customer.id\n      }\n    })\n  } catch (error) {\n    logger.error('Failed to store customer profile', {}, error as Error)\n    throw error\n  }\n}\n\n/**\n * Update customer profile\n */\nasync function updateCustomerProfile(customer: Stripe.Customer) {\n  try {\n    // Implement your customer profile update logic here\n    \n    logger.info('Customer profile updated', {\n      metadata: {\n        customerId: customer.id\n      }\n    })\n  } catch (error) {\n    logger.error('Failed to update customer profile', {}, error as Error)\n    throw error\n  }\n}\n\n/**\n * Process invoice payment\n */\nasync function processInvoicePayment(invoice: Stripe.Invoice) {\n  try {\n    // Implement your invoice processing logic here\n    \n    logger.info('Invoice payment processed', {\n      metadata: {\n        invoiceId: invoice.id\n      }\n    })\n  } catch (error) {\n    logger.error('Failed to process invoice payment', {}, error as Error)\n    throw error\n  }\n}\n\n/**\n * Handle invoice failure\n */\nasync function handleInvoiceFailure(invoice: Stripe.Invoice) {\n  try {\n    // Implement your invoice failure handling logic here\n    \n    logger.info('Invoice failure handled', {\n      metadata: {\n        invoiceId: invoice.id\n      }\n    })\n  } catch (error) {\n    logger.error('Failed to handle invoice failure', {}, error as Error)\n    throw error\n  }\n}